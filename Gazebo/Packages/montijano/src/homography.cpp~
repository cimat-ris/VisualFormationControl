/*Patricia Marisol del Carmen Tavares Ram√≠rez
November 20th, 2017
This ROS code is used to connect rotors_simulator hummingbird's camera 
and process the images to obtain the homography.
A simple explanation of what it's done:
	- Take a picture of the init position of the drone (gazebo origin)
	- Move the drone to a defined pose
	- Take picture from new pose
	- Process the homography between the two images.
*/

/* ROS libraries*/
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <sensor_msgs/image_encodings.h>
#include <trajectory_msgs/MultiDOFJointTrajectory.h>
#include <geometry_msgs/PointStamped.h>
#include <mav_msgs/default_topics.h>
#include <mav_msgs/conversions.h>

/* OpenCv Libraries*/
/*Meanwhile I'm using this opencv 2.4.10, the i'll have to change it to
opencv3*/
//#include <opencv2/xfeatures2d.hpp>
#include <opencv2/features2d.hpp>
#include <opencv2/core.hpp>
#include <opencv2/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/imgproc.hpp>
#include "opencv2/calib3d.hpp"

/* defining  ratio for flann*/
#define RATIO 0.7

/* Declaring namespaces */
//using namespace cv::xfeatures2d;
using namespace cv;
using namespace std;

/* Declaring callbacks and other functions*/
void imageCallback(const sensor_msgs::Image::ConstPtr& msg);
void positionCallback(const geometry_msgs::PointStamped::ConstPtr& msg);
float abs(float a);

/* Declaring objetcs to send and receive messages */
sensor_msgs::ImagePtr image_msg;
geometry_msgs::PointStamped pos_msg;

/* defining where the drone will move*/
float X = 0.5; float Y = 0; float Z = 1.0;

/* declaring detector params */
int nfeatures=200;
float scaleFactor=1.2f;
int nlevels=8;
int edgeThreshold=15; // Changed default (31);
int firstLevel=0;
int WTA_K=2;
int scoreType=cv::ORB::HARRIS_SCORE;
int patchSize=31;
int fastThreshold=20;

/* Declaring ORB detector to use it everywhere */
Ptr<ORB> detector;

/* Declaring data for the desired pos: image, descriptors and keypoints of the desired pose */
Mat desired_descriptors;
vector<KeyPoint> desired_kp;
Mat desired_img;
Mat K;

/* Main function */
int main(int argc, char **argv){

	/***************************************************************************************** INIT */
	ros::init(argc,argv,"homography");
	ros::NodeHandle nh;
	image_transport::ImageTransport it(nh);

	/************************************************************* CREATING PUBLISHER AND SUBSCRIBER */
	image_transport::Subscriber image_sub = it.subscribe("/hummingbird/camera_nadir/image_raw",1,imageCallback);
	image_transport::Publisher image_pub = it.advertise("matching",1);
	ros::Rate rate(40);

	/************************************************************************** OPENING DESIRED IMAGE */
	desired_img = imread("/home/robotics/patty_ws/src/homography/src/desired.png",IMREAD_COLOR);
	Ptr<ORB> orb = ORB::create(nfeatures,scaleFactor,nlevels,edgeThreshold,firstLevel,WTA_K,scoreType,patchSize,fastThreshold);
    orb->detect(desired_img, desired_kp);
	orb->compute(desired_img,desired_kp, desired_descriptors);

	/******************************************************************************* MOVING TO A POSE */
	int moved = 0;
	ros::Publisher pos_pub = nh.advertise<trajectory_msgs::MultiDOFJointTrajectory>("/hummingbird/command/trajectory",1);
	ros::Subscriber pos_sub = nh.subscribe<geometry_msgs::PointStamped>("/hummingbird/ground_truth/position",1,positionCallback);

	/******************************************************************************* CAMERA MATRIX */
	K = Mat(3,3, CV_64F, double(0));
	K.at<double>(0,0) = 241.4268236;
	K.at<double>(1,1) = 241.4268236;
	K.at<double>(0,1) = 376.0;
	K.at<double>(1,0) = 240.0;
	K.at<double>(2,2) = 1.0;

	while(ros::ok()){
		//get a msg
		ros::spinOnce();
		//if the drone moved to the defined position
		if(moved == 1){
			image_pub.publish(image_msg);  
			rate.sleep(); 
		}else{ //the drone hasn't reach the defined pos
			trajectory_msgs::MultiDOFJointTrajectory msg;
			Eigen::VectorXd position; position.resize(3); 
			position(0) = X; position(1) = Y; position(2) = Z;
			// prepare msg
			msg.header.stamp=ros::Time::now();
			mav_msgs::msgMultiDofJointTrajectoryFromPositionYaw(position, 0.0 , &msg);	
			//publish
			pos_pub.publish(msg);
			rate.sleep();		
		}

		//verify if it moved
		float error = abs((pos_msg.point.x-X)*(pos_msg.point.x-X)+(pos_msg.point.y-Y)*(pos_msg.point.y-Y)+(pos_msg.point.z-Z)*(pos_msg.point.z-Z));
		if(moved==0 && error< 10e-3)
			moved = 1;			
	}

	return 0;
}

/* 
	function: imageCallback
	description: uses the msg image and converts it to and opencv image to obtain the kp and 
	descriptors. Right now the resulting image is published.
	params: 
		msg: ptr to the msg image.
*/

void imageCallback(const sensor_msgs::Image::ConstPtr& msg){
	try{
		Mat img=cv_bridge::toCvShare(msg,"bgr8")->image;
		
		/*************************************************************KP*/
		Mat descriptors; vector<KeyPoint> kp; //declaring kp and descriptors for actual image
		
		/*************************************************************Creatring ORB*/
		Ptr<ORB> orb = ORB::create(nfeatures,scaleFactor,nlevels,edgeThreshold,firstLevel,WTA_K,scoreType,patchSize,fastThreshold);
    	orb->detect(img, kp);
		orb->compute(img, kp, descriptors);

		/************************************************************* Using flann for matching*/
		FlannBasedMatcher matcher(new flann::LshIndexParams(20, 10, 2));
  		vector<vector<DMatch>> matches;
 		matcher.knnMatch(desired_descriptors,descriptors,matches,2);
		
		/************************************************************* Processing to get only goodmatches*/
		vector<DMatch> goodMatches;

		for(int i = 0; i < matches.size(); ++i){
        	if (matches[i][0].distance < matches[i][1].distance * RATIO)
            	goodMatches.push_back(matches[i][0]);
    	}
	
		/************************************************************* Draw only "good" matches */
		Mat img_matches = Mat::zeros(img.rows, img.cols * 2, img.type());
		drawMatches(desired_img, desired_kp, img, kp, 
					goodMatches, img_matches, 
					Scalar::all(-1), Scalar::all(-1), vector<char>(), DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);
		
		/************************************************************* Prepare message */
		image_msg = cv_bridge::CvImage(std_msgs::Header(),sensor_msgs::image_encodings::BGR8,img_matches).toImageMsg();
		image_msg->header.frame_id = "matching_image";
     	image_msg->width = img_matches.cols;//img_rgb.cols;
      	image_msg->height = img_matches.rows;
      	image_msg->is_bigendian = false;
    	image_msg->step = sizeof(unsigned char) * img_matches.cols*3;
      	image_msg->header.stamp = ros::Time::now();

		/************************************************************* Findig and decomposing homography */
		 //-- transforming goodmatches to points
  		vector<Point2f> p1;
  		vector<Point2f> p2;

  		for(int i = 0; i < goodMatches.size(); i++){
    		//-- Get the keypoints from the good matches
    		p1.push_back(desired_kp[goodMatches[i].queryIdx].pt);
    		p2.push_back(kp[goodMatches[i].trainIdx].pt);
		}
	     
		Mat H = findHomography(p1, p2 ,CV_RANSAC, 3);
		cout << H << endl;

	}catch (cv_bridge::Exception& e){
     	ROS_ERROR("Could not convert from '%s' to 'bgr8'.", msg->encoding.c_str());
   }
}

/* 
	function: positionCallback
	description: gets the position of the drone and assigns it to the variable point_msg.
	params: ptr to msg.
*/
void positionCallback(const geometry_msgs::PointStamped::ConstPtr& msg){
	pos_msg.point.x = msg->point.x;
	pos_msg.point.y = msg->point.y;
	pos_msg.point.z = msg->point.z;
}

/*
	function: abs
	description: dummy function to get and absolute value.
	params: number to use in the function.
*/
float abs(float a){
	if(a<0)
		return -a;
	return a;
}
